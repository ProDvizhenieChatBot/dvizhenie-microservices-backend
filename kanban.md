---

### **Общая стратегия и параллельная работа**

Задачи для **API Service** являются центральными, но работа над **File Storage Service** может вестись **полностью параллельно** с самого начала. Разработчикам достаточно договориться о контракте (например, `file-storage` будет принимать файл и возвращать `file_id`).

Работа над **Bot Service** зависит от готовности эндпоинтов в **API Service**, поэтому эти задачи лучше брать после завершения соответствующих зависимостей.

### **Фаза 1: Реализация базовой логики сервисов**

---
#### СДЕЛАНО [DONE]**Задачи для `API Service` (Основной поток)**

<!-- **Задача 1.1**
*   **Название задачи:** Реализовать создание черновика заявки
*   **Сервис:** `api-service`
*   **Описание:** Создать эндпоинт `POST /api/v1/applications`. Он должен принимать минимальный набор данных (например, ID пользователя из сессии), создавать новую запись в таблице `applications` со статусом `draft` и возвращать ID созданной заявки.
*   **Критерии готовности:** Эндпоинт существует, успешно создает запись в БД и возвращает `201 Created` с ID. Есть базовая Pydantic-модель для входящих данных.
*   **Зависимости:** Нет (миграция уже существует).

**Задача 1.2**
*   **Название задачи:** Реализовать сохранение прогресса анкеты
*   **Сервис:** `api-service`
*   **Описание:** Создать эндпоинт `PATCH /api/v1/applications/{id}`. Он должен принимать JSON с данными анкеты и обновлять поле `data` у существующей заявки. Это позволит фронтенду сохранять анкету по частям.
*   **Критерии готовности:** Эндпоинт принимает ID заявки и JSON, корректно обновляет данные в БД. Возвращает `200 OK`.
*   **Зависимости:** Задача 1.1.

**Задача 1.3**
*   **Название задачи:** Реализовать получение данных анкеты
*   **Сервис:** `api-service`
*   **Описание:** Создать эндпоинт `GET /api/v1/applications/{id}`. Он должен возвращать все данные по конкретной заявке, включая JSON-поле `data`.
*   **Критерии готовности:** Эндпоинт по ID возвращает полную информацию о заявке.
*   **Зависимости:** Задача 1.1.

**Задача 1.4**
*   **Название задачи:** Улучшить создание сессии для Telegram
*   **Сервис:** `api-service`
*   **Описание:** Модифицировать эндпоинт `POST /api/v1/sessions/telegram`. Теперь он должен не просто генерировать токен, а сначала создавать черновик заявки (используя логику из Задачи 1.1), а затем возвращать JWT или другой защищенный токен, в котором зашифрован `application_id`.
*   **Критерии готовности:** При вызове эндпоинта создается новая заявка со статусом `draft`, и возвращается токен, содержащий ее ID.
*   **Зависимости:** Задача 1.1. -->

---
#### **Задачи для `File Storage Service` (Можно делать параллельно с задачами 1.1 - 1.4)**

<!-- **Задача 2.1**
*   **Название задачи:** Интегрировать S3-клиент (boto3)
*   **Сервис:** `file-storage-service`
*   **Описание:** Добавить `boto3` в зависимости проекта. Создать модуль (например, `app/s3_client.py`), который будет инициализировать клиент для работы с MinIO, используя конфигурацию из `.env` (endpoint, keys, bucket name).
*   **Критерии готовности:** Клиент успешно инициализируется при старте сервиса и может подключиться к MinIO.
*   **Зависимости:** Нет.

**Задача 2.2**
*   **Название задачи:** Реализовать логику загрузки файла в MinIO
*   **Сервис:** `file-storage-service`
*   **Описание:** Реализовать логику эндпоинта `POST /api/v1/files`. Он должен принимать `UploadFile`, генерировать для него уникальное имя (например, `uuid4()`), и загружать его в бакет MinIO с помощью S3-клиента. В ответ возвращать уникальный `file_id` (который может быть сгенерированным именем файла).
*   **Критерии готовности:** Файлы, отправленные на эндпоинт, появляются в бакете MinIO. Эндпоинт возвращает `file_id`.
*   **Зависимости:** Задача 2.1. -->

**Задача 2.3**
*   **Название задачи:** Реализовать генерацию ссылки для скачивания
*   **Сервис:** `file-storage-service`
*   **Описание:** Реализовать логику эндпоинта `GET /api/v1/files/{file_id}/download-link`. Он должен использовать S3-клиент для генерации временного (например, на 1 час) предварительно подписанного URL (pre-signed URL) для скачивания файла.
*   **Критерии готовности:** Эндпоинт по `file_id` возвращает рабочую временную ссылку на скачивание файла из MinIO.
*   **Зависимости:** Задача 2.1.

---

### **Фаза 2: Администрирование и интеграция**

Эти задачи можно начинать после завершения базовых из Фазы 1.

#### **Задачи для `API Service`**

**(Epic) Задача 3.1: Реализовать аутентификацию администраторов по логину/паролю**
*   **Описание:** Реализовать систему входа для администраторов с использованием логина и пароля. Система должна использовать JWT для управления сессиями (access и refresh токены). Также необходимо реализовать механизм "мастер-администратора", учетные данные которого задаются в `.env` и который может создавать других администраторов.
*   **Подзадачи:**

    *   **Задача 3.1.1:** Добавить переменные для мастер-админа в конфигурацию
        *   **Описание:** Добавить в файлы `.env.example` и `.env` переменные для мастер-администратора, например: `MASTER_ADMIN_USER` и `MASTER_ADMIN_PASSWORD`.
        *   **Критерии готовности:** Переменные добавлены в файлы конфигурации.

    *   **Задача 3.1.2:** Создать модель `AdminUser` и соответствующую миграцию
        *   **Описание:** В `db_models.py` создать SQLAlchemy-модель `AdminUser` с полями `id`, `username`, `hashed_password`, `is_active`. `username` должен быть уникальным. Сгенерировать и применить Alembic-миграцию для создания этой таблицы.
        *   **Критерии готовности:** В базе данных появилась таблица `admin_users`.

    *   **Задача 3.1.3:** Реализовать логику хеширования паролей и создания мастер-админа
        *   **Описание:** Добавить утилиты для работы с паролями (например, с использованием `passlib`). Реализовать скрипт или FastAPI startup-событие, которое при запуске сервиса проверяет наличие мастер-администратора в БД и, если его нет, создает его, используя данные из `.env`.
        *   **Критерии готовности:** Мастер-админ автоматически создается в БД при первом запуске сервиса. Пароли надежно хешируются.

    *   **Задача 3.1.4:** Реализовать эндпоинт для входа в систему
        *   **Описание:** Создать эндпоинт `POST /api/v1/auth/login`. Он должен принимать `username` и `password`, проверять их корректность и, в случае успеха, генерировать и возвращать пару токенов: `access_token` и `refresh_token`.
        *   **Критерии готовности:** Администратор может войти в систему и получить JWT-токены.

    *   **Задача 3.1.5:** Реализовать эндпоинт для создания новых администраторов
        *   **Описание:** Создать защищенный эндпоинт `POST /api/v1/admins`, который позволяет авторизованному администратору создавать новые учетные записи для других администраторов.
        *   **Критерии готовности:** Мастер-админ может создавать новые учетные записи.

**Задача 3.2: Защитить эндпоинты для администраторов**
*   **Описание:** Создать FastAPI-зависимость (`Depends`), которая проверяет `access_token` из заголовка `Authorization`. Применить эту зависимость ко всем эндпоинтам, которые предназначены для админов (например, к эндпоинту для создания админов из **Задачи 3.1.5**).
*   **Сервис:** `api-service`
*   **Критерии готовности:** Эндпоинты, помеченные как админские, возвращают ошибку `401 Unauthorized` без валидного JWT-токена.
*   **Зависимости:** **Задача 3.1** (весь эпик).

**Задача 3.3**
*   **Название задачи:** Реализовать эндпоинт для просмотра списка заявок
*   **Сервис:** `api-service`
*   **Описание:** Создать эндпоинт `GET /api/v1/applications` для администраторов. Он должен возвращать список всех заявок с возможностью пагинации и фильтрации (например, по статусу). Эндпоинт должен быть защищен.
*   **Критерии готовности:** Админ может получить список заявок.
*   **Зависимости:** Задача 1.1, Задача 3.2.

**Задача 3.4**
*   **Название задачи:** Создать модель и миграцию для хранения схемы анкеты
*   **Сервис:** `api-service`
*   **Описание:** Создать в `db_models.py` модель `FormSchema` для хранения JSON-схем анкет. Сгенерировать и применить новую Alembic-миграцию.
*   **Критерии готовности:** В базе данных появилась таблица `form_schemas`.
*   **Зависимости:** Нет.

**Задача 3.5**
*   **Название задачи:** Переключить выдачу схемы анкеты на БД
*   **Сервис:** `api-service`
*   **Описание:** Изменить логику эндпоинта `GET /api/v1/forms/schema/active`. Вместо чтения статического JSON-файла он должен запрашивать из БД последнюю активную схему и возвращать ее.
*   **Критерии готовности:** Эндпоинт отдает схему из базы данных.
*   **Зависимости:** Задача 3.4.

---
#### **Задачи для `Bot Service`**

**Задача 4.1**
*   **Название задачи:** Интегрировать реальное создание сессии
*   **Сервис:** `bot-service`
*   **Описание:** Обновить обработчик команды `/start`. Теперь он должен вызывать эндпоинт `POST /api/v1/sessions/telegram` из `api-service` и использовать полученный оттуда реальный токен в URL для Mini App.
*   **Критерии готовности:** При старте бота создается реальная заявка в БД, а кнопка Mini App содержит токен для доступа к ней.
*   **Зависимости:** Задача 1.4 (должна быть завершена и доступна в Docker-сети).