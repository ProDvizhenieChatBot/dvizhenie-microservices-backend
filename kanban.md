---

### **Общая стратегия и параллельная работа**

Задачи для **API Service** являются центральными, но работа над **File Storage Service** может вестись **полностью параллельно** с самого начала. Разработчикам достаточно договориться о контракте (например, `file-storage` будет принимать файл и возвращать `file_id`).

Работа над **Bot Service** зависит от готовности эндпоинтов в **API Service**, поэтому эти задачи лучше брать после завершения соответствующих зависимостей.

### **Фаза 1: Реализация базовой логики сервисов**

---
#### **Задачи для `API Service` (Основной поток)**

**Задача 1.1**
*   **Название задачи:** Реализовать создание черновика заявки
*   **Сервис:** `api-service`
*   **Описание:** Создать эндпоинт `POST /api/v1/applications`. Он должен принимать минимальный набор данных (например, ID пользователя из сессии), создавать новую запись в таблице `applications` со статусом `draft` и возвращать ID созданной заявки.
*   **Критерии готовности:** Эндпоинт существует, успешно создает запись в БД и возвращает `201 Created` с ID. Есть базовая Pydantic-модель для входящих данных.
*   **Зависимости:** Нет (миграция уже существует).

**Задача 1.2**
*   **Название задачи:** Реализовать сохранение прогресса анкеты
*   **Сервис:** `api-service`
*   **Описание:** Создать эндпоинт `PATCH /api/v1/applications/{id}`. Он должен принимать JSON с данными анкеты и обновлять поле `data` у существующей заявки. Это позволит фронтенду сохранять анкету по частям.
*   **Критерии готовности:** Эндпоинт принимает ID заявки и JSON, корректно обновляет данные в БД. Возвращает `200 OK`.
*   **Зависимости:** Задача 1.1.

**Задача 1.3**
*   **Название задачи:** Реализовать получение данных анкеты
*   **Сервис:** `api-service`
*   **Описание:** Создать эндпоинт `GET /api/v1/applications/{id}`. Он должен возвращать все данные по конкретной заявке, включая JSON-поле `data`.
*   **Критерии готовности:** Эндпоинт по ID возвращает полную информацию о заявке.
*   **Зависимости:** Задача 1.1.

**Задача 1.4**
*   **Название задачи:** Улучшить создание сессии для Telegram
*   **Сервис:** `api-service`
*   **Описание:** Модифицировать эндпоинт `POST /api/v1/sessions/telegram`. Теперь он должен не просто генерировать токен, а сначала создавать черновик заявки (используя логику из Задачи 1.1), а затем возвращать JWT или другой защищенный токен, в котором зашифрован `application_id`.
*   **Критерии готовности:** При вызове эндпоинта создается новая заявка со статусом `draft`, и возвращается токен, содержащий ее ID.
*   **Зависимости:** Задача 1.1.

---
#### **Задачи для `File Storage Service` (Можно делать параллельно с задачами 1.1 - 1.4)**

**Задача 2.1**
*   **Название задачи:** Интегрировать S3-клиент (boto3)
*   **Сервис:** `file-storage-service`
*   **Описание:** Добавить `boto3` в зависимости проекта. Создать модуль (например, `app/s3_client.py`), который будет инициализировать клиент для работы с MinIO, используя конфигурацию из `.env` (endpoint, keys, bucket name).
*   **Критерии готовности:** Клиент успешно инициализируется при старте сервиса и может подключиться к MinIO.
*   **Зависимости:** Нет.

**Задача 2.2**
*   **Название задачи:** Реализовать логику загрузки файла в MinIO
*   **Сервис:** `file-storage-service`
*   **Описание:** Реализовать логику эндпоинта `POST /api/v1/files`. Он должен принимать `UploadFile`, генерировать для него уникальное имя (например, `uuid4()`), и загружать его в бакет MinIO с помощью S3-клиента. В ответ возвращать уникальный `file_id` (который может быть сгенерированным именем файла).
*   **Критерии готовности:** Файлы, отправленные на эндпоинт, появляются в бакете MinIO. Эндпоинт возвращает `file_id`.
*   **Зависимости:** Задача 2.1.

**Задача 2.3**
*   **Название задачи:** Реализовать генерацию ссылки для скачивания
*   **Сервис:** `file-storage-service`
*   **Описание:** Реализовать логику эндпоинта `GET /api/v1/files/{file_id}/download-link`. Он должен использовать S3-клиент для генерации временного (например, на 1 час) предварительно подписанного URL (pre-signed URL) для скачивания файла.
*   **Критерии готовности:** Эндпоинт по `file_id` возвращает рабочую временную ссылку на скачивание файла из MinIO.
*   **Зависимости:** Задача 2.1.

---

### **Фаза 2: Администрирование и интеграция**

Эти задачи можно начинать после завершения базовых из Фазы 1.

#### **Задачи для `API Service`**

**(Epic) Задача 3.1: Реализовать аутентификацию администраторов через Yandex OAuth**
*   **Описание:** Заменить простую аутентификацию по логину/паролю на безопасный и стандартный процесс входа через Яндекс.
*   **Подзадачи:**

    *   **Задача 3.1.1:** Зарегистрировать приложение в Yandex Cloud
        *   **Описание:** Создать новое приложение в консоли Yandex Cloud, указать права (например, доступ к email), настроить `redirect_uri`. Сохранить полученные `client_id` и `client_secret` в `.env` и `.env.example`.
        *   **Критерии готовности:** Учетные данные для OAuth сохранены в конфигурации проекта.

    *   **Задача 3.1.2:** Создать эндпоинт для редиректа на Яндекс
        *   **Описание:** Реализовать `GET /api/v1/auth/yandex/login`, который формирует правильный URL для авторизации в Яндексе и выполняет на него редирект (HTTP 307).
        *   **Критерии готовности:** При переходе по адресу эндпоинта пользователя перебрасывает на страницу входа Яндекса.

    *   **Задача 3.1.3:** Реализовать callback-эндпоинт
        *   **Описание:** Реализовать `GET /api/v1/auth/yandex/callback`. Этот эндпоинт должен принимать `code` из query-параметров, обменивать его на `access_token`, делая сервер-серверный запрос к Яндексу.
        *   **Критерии готовности:** Эндпоинт успешно получает `access_token` от Яндекса. В случае ошибки (например, неверный `code`) возвращает ошибку.

    *   **Задача 3.1.4:** Реализовать логику получения данных пользователя и выдачи внутреннего JWT
        *   **Описание:** В `callback`-эндпоинте, после получения `access_token`, сделать запрос к API Яндекса для получения информации о пользователе (в первую очередь `email`). Найти или создать запись администратора в нашей БД. Сгенерировать внутренний JWT-токен для этого пользователя и вернуть его (например, в JSON-ответе или через redirect с токеном на фронтенд).
        *   **Критерии готовности:** После успешной авторизации в Яндексе эндпоинт возвращает JWT, который идентифицирует пользователя в нашей системе.

**Задача 3.2: Защитить эндпоинты для администраторов**
*   **Описание:** Создать FastAPI-зависимость (`Depends`), которая проверяет внутренний JWT-токен (полученный в **Задаче 3.1.4**). Применить эту зависимость ко всем эндпоинтам, которые предназначены для админов.
*   **Сервис:** `api-service`
*   **Критерии готовности:** Эндпоинты, помеченные как админские, недоступны без валидного JWT-токена.
*   **Зависимости:** **Задача 3.1** (весь эпик).

**Задача 3.3**
*   **Название задачи:** Реализовать эндпоинт для просмотра списка заявок
*   **Сервис:** `api-service`
*   **Описание:** Создать эндпоинт `GET /api/v1/applications` для администраторов. Он должен возвращать список всех заявок с возможностью пагинации и фильтрации (например, по статусу). Эндпоинт должен быть защищен.
*   **Критерии готовности:** Админ может получить список заявок.
*   **Зависимости:** Задача 1.1, Задача 3.2.

**Задача 3.4**
*   **Название задачи:** Создать модель и миграцию для хранения схемы анкеты
*   **Сервис:** `api-service`
*   **Описание:** Создать в `db_models.py` модель `FormSchema` для хранения JSON-схем анкет. Сгенерировать и применить новую Alembic-миграцию.
*   **Критерии готовности:** В базе данных появилась таблица `form_schemas`.
*   **Зависимости:** Нет.

**Задача 3.5**
*   **Название задачи:** Переключить выдачу схемы анкеты на БД
*   **Сервис:** `api-service`
*   **Описание:** Изменить логику эндпоинта `GET /api/v1/forms/schema/active`. Вместо чтения статического JSON-файла он должен запрашивать из БД последнюю активную схему и возвращать ее.
*   **Критерии готовности:** Эндпоинт отдает схему из базы данных.
*   **Зависимости:** Задача 3.4.

---
#### **Задачи для `Bot Service`**

**Задача 4.1**
*   **Название задачи:** Интегрировать реальное создание сессии
*   **Сервис:** `bot-service`
*   **Описание:** Обновить обработчик команды `/start`. Теперь он должен вызывать эндпоинт `POST /api/v1/sessions/telegram` из `api-service` и использовать полученный оттуда реальный токен в URL для Mini App.
*   **Критерии готовности:** При старте бота создается реальная заявка в БД, а кнопка Mini App содержит токен для доступа к ней.
*   **Зависимости:** Задача 1.4 (должна быть завершена и доступна в Docker-сети).