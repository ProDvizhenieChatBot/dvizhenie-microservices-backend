# kanban.md
### **Общая стратегия и параллельная работа**

Основная фаза рефакторинга (**Фаза 2**) завершена. Мы переходим к реализации оставшихся функций MVP, таких как хранение схемы анкеты в БД и добавление конечных точек для веб-сессий и экспорта данных.

---
### **Фаза 1: Реализация базовой логики сервисов [DONE]**

*   **Статус:** Завершено.
*   **Результат:** Настроена базовая микросервисная архитектура (Docker, Nginx). Реализованы начальные версии сервисов, включая полнофункциональный `file-storage-service`.

---
### **Фаза 2: Основная бизнес-логика и функции администратора [DONE]**

*   **Статус:** Завершено.
*   **Результат:** Проведен полный рефакторинг `api-service` для поддержки основного бизнес-процесса.
    *   **Аутентификация администраторов:** Реализована через Nginx Basic Auth.
    *   **Рефакторинг моделей данных:** Модель `Application` переведена на `UUID`, добавлено поле `telegram_id` и создана связанная модель `ApplicationFile`. База данных успешно мигрирована на новую схему.
    *   **Реализация API эндпоинтов:** Созданы все необходимые эндпоинты для администраторов (просмотр, обновление статуса заявок) и для публичного использования Mini App (сохранение прогресса, привязка файлов, отправка анкеты).
    *   **Интеграция с `bot-service`:** Обновлена логика создания сессий. Теперь `bot-service` передает `telegram_id`, что позволяет пользователям возобновлять свои незавершенные заявки.

---
### **Фаза 3: Финальные функции MVP и улучшения**

#### **Задачи для `API Service`**

<!-- **(Epic) Задача 4.1: Перенести схему анкеты в базу данных**
*   **Описание:** Уйти от статического `form_schema.json` для гибкого управления анкетой.
*   **Подзадачи:**
    1.  Создать SQLAlchemy-модель `FormSchema` в `db_models.py` (`id`, `version`, `schema_data (JSON)`, `is_active (boolean)`).
    2.  Сгенерировать миграцию Alembic для этой таблицы.
    3.  Обновить `GET /api/v1/forms/schema/active`, чтобы эндпоинт загружал схему из БД, у которой `is_active=true`.
    4.  Создать эндпоинт для администраторов `POST /api/v1/admin/forms/schema` для загрузки новой версии схемы. Логика должна установить `is_active=false` для всех старых версий и `is_active=true` для новой.
*   **Критерии готовности:** Схема анкеты хранится, запрашивается и обновляется через БД.
*   **Зависимости:** Нет. -->

<!-- **Задача 6.1: Реализовать создание сессии для веб-виджета**
*   **Описание:** Создать эндпоинт для пользователей, начинающих заполнение анкеты с сайта.
*   **Подзадачи:**
    1.  Реализовать эндпоинт `POST /api/v1/sessions/web`.
    2.  Логика: создать новую `Application` со статусом `draft` и `telegram_id = null`.
    3.  Вернуть `application_uuid` созданной заявки. Фронтенд-команда отвечает за сохранение этого UUID в cookie.
*   **Критерии готовности:** Веб-виджет может получить UUID для новой сессии.
*   **Зависимости:** Нет. -->

**Задача 6.2: Реализовать экспорт заявок в XLSX**
*   **Описание:** Дать администраторам возможность выгружать данные по заявкам в формате XLSX.
*   **Подзадачи:**
    1.  Создать эндпоинт для администраторов `GET /api/v1/admin/applications/export`.
    2.  Реализовать логику: получить заявки из БД, "расплющить" JSON-поле `data` в плоскую структуру.
    3.  Использовать библиотеку (например, `pandas` или `openpyxl`) для генерации XLSX-файла в памяти.
    4.  Вернуть файл с помощью `StreamingResponse` FastAPI.
*   **Критерии готовности:** Администратор может скачать XLSX-файл с данными заявок через API.
*   **Зависимости:** Нет.

**Задача 6.3: Реализовать скачивание документов заявки ZIP-архивом**
*   **Описание:** Дать сотрудникам фонда возможность скачать все документы, приложенные к одной заявке, единым ZIP-архивом.
*   **Подзадачи (Backend - API Service):**
    1.  Создать новый эндпоинт для администраторов: `GET /api/v1/admin/applications/{application_uuid}/download-documents`.
    2.  Внутри эндпоинта получить из БД список всех `ApplicationFile` (включая `file_id` и `original_filename`), связанных с этой заявкой.
    3.  Для каждого `file_id` из списка, сделать внутренний HTTP-запрос к `file-storage-service` для получения временной ссылки на скачивание (используя существующий эндпоинт `/files/{file_id}/download-link`).
    4.  Сделать HTTP-запрос по полученной временной ссылке, чтобы скачать содержимое каждого файла в память.
    5.  Используя стандартную библиотеку `zipfile` и `io.BytesIO`, сформировать ZIP-архив в памяти, добавляя в него каждый скачанный файл под его `original_filename`.
    6.  Вернуть сгенерированный архив клиенту с помощью `StreamingResponse` FastAPI, установив корректные HTTP-заголовки (`Content-Type: application/zip` и `Content-Disposition`, чтобы браузер предложил сохранить файл).
*   **Критерии готовности:** Администратор, имеющий доступ к админ-панели, может по одному клику скачать ZIP-архив со всеми документами конкретной заявки.
*   **Зависимости:** Требует работающей логики привязки файлов к заявкам.


**Задача 7.1: Добавить базовое логирование**
*   **Описание:** Улучшить наблюдаемость и отладку сервисов путем добавления структурированного логирования.
*   **Подзадачи:**
    1.  **API Service:** Настроить логирование для ключевых операций: создание сессии, получение/обновление заявок, ошибки.
    2.  **Bot Service:** Добавить логирование для вызовов API и ошибок при взаимодействии с Telegram.
    3.  **File Storage Service:** Улучшить логирование при загрузке файлов и возникновении ошибок S3.
*   **Критерии готовности:** В консоли Docker видны информативные логи о работе сервисов.
*   **Зависимости:** Нет, может выполняться параллельно.

**Задача 7.2: Реализовать проверку статуса заявки для пользователя**
*   **Описание:** Дать пользователю возможность узнать текущий статус своей заявки.
*   **Подзадачи (Backend - API Service):**
    1.  Создать эндпоинт `GET /api/v1/sessions/telegram/status`, принимающий `telegram_id` и возвращающий статус последней заявки (`{"status": "..."}`).
    2.  Создать эндпоинт `GET /api/v1/applications/{application_uuid}/public/status` для веб-виджета, который возвращает только статус заявки.
*   **Подзадачи (Frontend - Bot Service):**
    1.  Реализовать обработчик для команды `/status`.
*   **Критерии готовности:** Пользователь может получить актуальный статус своей заявки через Telegram-бот или по прямой ссылке.
*   **Зависимости:** Нет.

### **Фаза 4: Документация**

**Задача 8.1: Создать руководство по `form_schema.json`**
*   **Описание:** Подготовить документ на русском языке, объясняющий структуру и все возможные поля JSON-схемы анкеты.
*   **Целевая аудитория:** Менеджеры фонда, которые будут редактировать анкету в будущем.
*   **Содержание:**
    1.  Общая структура: `name`, `version`, `start_step_id`, `steps`.
    2.  Описание объекта "шаг" (`step`): `step_id`, `title`, `fields`, `navigation`.
    3.  Описание объекта "поле" (`field`): `field_id`, `type`, `label`, `required`, `options`.
    4.  Описание логики навигации (`navigation`) и условного отображения полей (`condition`).
*   **Критерии готовности:** Создан понятный `.md` файл с документацией.
*   **Зависимости:** Нет.

**Задача 9.1: Создать динамический сервис документации API**
*   **Описание:** Заменить статический `openapi.yaml` на динамический микросервис `docs-service`, который "на лету" собирает и объединяет OpenAPI спецификации от всех остальных сервисов.
*   **Подзадачи:**
    1.  Создать новый сервис `docs-service` на FastAPI, который опрашивает `api-service` и `file-storage-service` для получения их `openapi.json`.
    2.  Реализовать логику слияния спецификаций в единый документ.
    3.  Добавить `docs-service` в `docker-compose.yml`.
    4.  Обновить конфигурацию `nginx` для проксирования запросов к `/docs` и `/openapi.json` на новый `docs-service`.
    5.  Удалить статический файл `openapi.yaml` из корневой директории проекта.
*   **Критерии готовности:** По адресу `http://localhost:8000/docs` открывается единая, актуальная документация по всем API эндпоинтам проекта.
*   **Зависимости:** Нет.
---
